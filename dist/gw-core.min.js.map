{"version":3,"file":"gw-core.min.js","sources":["../js/utils.js","../js/random.js","../js/range.js","../js/gw.js"],"sourcesContent":["/**\n * GW.utils\n * @module utils\n */\n// DIRS are organized clockwise\n// - first 4 are arrow directions\n//   >> rotate 90 degrees clockwise ==>> newIndex = (oldIndex + 1) % 4\n//   >> opposite direction ==>> oppIndex = (index + 2) % 4\n// - last 4 are diagonals\n//   >> rotate 90 degrees clockwise ==>> newIndex = 4 + (oldIndex + 1) % 4;\n//   >> opposite diagonal ==>> newIndex = 4 + (index + 2) % 4;\nexport const DIRS = [[0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [1, -1], [-1, -1], [-1, 1]];\nexport const NO_DIRECTION = -1;\nexport const UP = 0;\nexport const RIGHT = 1;\nexport const DOWN = 2;\nexport const LEFT = 3;\nexport const RIGHT_UP = 4;\nexport const RIGHT_DOWN = 5;\nexport const LEFT_DOWN = 6;\nexport const LEFT_UP = 7;\n// CLOCK DIRS are organized clockwise, starting at UP\n// >> opposite = (index + 4) % 8\n// >> 90 degrees rotate right = (index + 2) % 8\n// >> 90 degrees rotate left = (8 + index - 2) % 8\nexport const CLOCK_DIRS = [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]];\nexport function NOOP() { }\nexport function TRUE() { return true; }\nexport function FALSE() { return false; }\nexport function ONE() { return 1; }\nexport function ZERO() { return 0; }\nexport function IDENTITY(x) { return x; }\n/**\n * clamps a value between min and max (inclusive)\n * @param v {Number} the value to clamp\n * @param min {Number} the minimum value\n * @param max {Number} the maximum value\n * @returns {Number} the clamped value\n */\nexport function clamp(v, min, max) {\n    if (v < min)\n        return min;\n    if (v > max)\n        return max;\n    return v;\n}\nexport function x(src) {\n    // @ts-ignore\n    return src.x || src[0] || 0;\n}\nexport function y(src) {\n    // @ts-ignore\n    return src.y || src[1] || 0;\n}\nexport function copyXY(dest, src) {\n    dest.x = x(src);\n    dest.y = y(src);\n}\nexport function addXY(dest, src) {\n    dest.x += x(src);\n    dest.y += y(src);\n}\nexport function equalsXY(dest, src) {\n    return (dest.x == x(src)) && (dest.y == y(src));\n}\nexport function lerpXY(a, b, pct) {\n    if (pct > 1) {\n        pct = pct / 100;\n    }\n    pct = clamp(pct, 0, 1);\n    const dx = x(b) - x(a);\n    const dy = y(b) - y(a);\n    const x2 = x(a) + Math.floor(dx * pct);\n    const y2 = y(a) + Math.floor(dy * pct);\n    return [x2, y2];\n}\nexport function distanceBetween(x1, y1, x2, y2) {\n    const x = Math.abs(x1 - x2);\n    const y = Math.abs(y1 - y2);\n    const min = Math.min(x, y);\n    return x + y - (0.6 * min);\n}\nexport function distanceFromTo(a, b) {\n    return distanceBetween(x(a), y(a), x(b), y(b));\n}\nexport function calcRadius(x, y) {\n    return distanceBetween(0, 0, x, y);\n}\nexport function dirBetween(x, y, toX, toY) {\n    let diffX = toX - x;\n    let diffY = toY - y;\n    if (diffX && diffY) {\n        const absX = Math.abs(diffX);\n        const absY = Math.abs(diffY);\n        if (absX >= 2 * absY) {\n            diffY = 0;\n        }\n        else if (absY >= 2 * absX) {\n            diffX = 0;\n        }\n    }\n    return [Math.sign(diffX), Math.sign(diffY)];\n}\nexport function dirFromTo(a, b) {\n    return dirBetween(x(a), y(a), x(b), y(b));\n}\nexport function dirIndex(dir) {\n    const x0 = x(dir);\n    const y0 = y(dir);\n    return DIRS.findIndex((a) => a[0] == x0 && a[1] == y0);\n}\nexport function isOppositeDir(a, b) {\n    if (a[0] + b[0] != 0)\n        return false;\n    if (a[1] + b[1] != 0)\n        return false;\n    return true;\n}\nexport function isSameDir(a, b) {\n    return a[0] == b[0] && a[1] == b[1];\n}\nexport function dirSpread(dir) {\n    const result = [dir];\n    if (dir[0] == 0) {\n        result.push([1, dir[1]]);\n        result.push([-1, dir[1]]);\n    }\n    else if (dir[1] == 0) {\n        result.push([dir[0], 1]);\n        result.push([dir[0], -1]);\n    }\n    else {\n        result.push([dir[0], 0]);\n        result.push([0, dir[1]]);\n    }\n    return result;\n}\nexport function stepFromTo(a, b, fn) {\n    const x0 = x(a);\n    const y0 = y(a);\n    const diff = [x(b) - x0, y(b) - y0];\n    const steps = Math.abs(diff[0]) + Math.abs(diff[1]);\n    const c = [0, 0];\n    const last = [99999, 99999];\n    for (let step = 0; step <= steps; ++step) {\n        c[0] = x0 + Math.floor(diff[0] * step / steps);\n        c[1] = y0 + Math.floor(diff[1] * step / steps);\n        if (c[0] != last[0] || c[1] != last[1]) {\n            fn(c[0], c[1]);\n        }\n        last[0] = c[0];\n        last[1] = c[1];\n    }\n}\n// Draws the smooth gradient that appears on a button when you hover over or depress it.\n// Returns the percentage by which the current tile should be averaged toward a hilite color.\nexport function smoothHiliteGradient(currentXValue, maxXValue) {\n    return Math.floor(100 * Math.sin(Math.PI * currentXValue / (maxXValue)));\n}\nfunction assignField(dest, src, key) {\n    const current = dest[key];\n    const updated = src[key];\n    if (current && current.copy && updated) {\n        current.copy(updated);\n    }\n    else if (current && current.clear && !updated) {\n        current.clear();\n    }\n    else if (current && current.nullify && !updated) {\n        current.nullify();\n    }\n    else if (updated && updated.clone) {\n        dest[key] = updated.clone(); // just use same object (shallow copy)\n    }\n    else if (updated && Array.isArray(updated)) {\n        dest[key] = updated.slice();\n    }\n    else if (current && Array.isArray(current)) {\n        current.length = 0;\n    }\n    else {\n        dest[key] = updated;\n    }\n}\n// export function copyObject(dest, src) {\n//   Object.keys(dest).forEach( (key) => {\n//     assignField(dest, src, key);\n//   });\n// }\n// export function assignObject(dest, src) {\n//   Object.keys(src).forEach( (key) => {\n//     assignField(dest, src, key);\n//   });\n// }\nexport function assignOmitting(omit, dest, src) {\n    if (typeof omit === 'string') {\n        omit = omit.split(/[,|]/g).map((t) => t.trim());\n    }\n    Object.keys(src).forEach((key) => {\n        if (omit.includes(key))\n            return;\n        assignField(dest, src, key);\n    });\n}\nexport function setDefault(obj, field, val) {\n    if (obj[field] === undefined) {\n        obj[field] = val;\n    }\n}\nexport function setDefaults(obj, def, custom = null) {\n    let dest;\n    Object.keys(def).forEach((key) => {\n        const origKey = key;\n        let defValue = def[key];\n        dest = obj;\n        // allow for => 'stats.health': 100\n        const parts = key.split('.');\n        while (parts.length > 1) {\n            key = parts.shift();\n            if (dest[key] === undefined) {\n                dest = dest[key] = {};\n            }\n            else if (typeof dest[key] !== 'object') {\n                ERROR('Trying to set default member on non-object config item: ' + origKey);\n            }\n            else {\n                dest = dest[key];\n            }\n        }\n        key = parts.shift();\n        let current = dest[key];\n        // console.log('def - ', key, current, defValue, obj, dest);\n        if (custom && custom(dest, key, current, defValue)) {\n            // do nothing\n        }\n        else if (current === undefined) {\n            if (defValue === null) {\n                dest[key] = null;\n            }\n            else if (Array.isArray(defValue)) {\n                dest[key] = defValue.slice();\n            }\n            else if (typeof defValue === 'object') {\n                dest[key] = defValue; // Object.assign({}, defValue); -- this breaks assigning a Color object as a default...\n            }\n            else {\n                dest[key] = defValue;\n            }\n        }\n    });\n}\nexport function kindDefaults(obj, def) {\n    function custom(dest, key, current, defValue) {\n        if (key.search(/[fF]lags$/) < 0)\n            return false;\n        if (!current) {\n            current = [];\n        }\n        else if (typeof current == 'string') {\n            current = current.split(/[,|]/).map((t) => t.trim());\n        }\n        else if (!Array.isArray(current)) {\n            current = [current];\n        }\n        if (typeof defValue === 'string') {\n            defValue = defValue.split(/[,|]/).map((t) => t.trim());\n        }\n        else if (!Array.isArray(defValue)) {\n            defValue = [defValue];\n        }\n        // console.log('flags', key, defValue, current);\n        dest[key] = defValue.concat(current);\n        return true;\n    }\n    return setDefaults(obj, def, custom);\n}\nexport function pick(obj, ...fields) {\n    const data = {};\n    fields.forEach((f) => {\n        const v = obj[f];\n        if (v !== undefined) {\n            data[f] = v;\n        }\n    });\n    return data;\n}\nexport function clearObject(obj) {\n    Object.keys(obj).forEach((key) => obj[key] = undefined);\n}\nexport function ERROR(message) {\n    throw new Error(message);\n}\nexport function WARN(...args) {\n    console.warn(...args);\n}\nexport function getOpt(obj, member, _default) {\n    const v = obj[member];\n    if (v === undefined)\n        return _default;\n    return v;\n}\nexport function firstOpt(field, ...args) {\n    for (let arg of args) {\n        if (typeof arg !== 'object' || Array.isArray(arg)) {\n            return arg;\n        }\n        if (arg[field] !== undefined) {\n            return arg[field];\n        }\n    }\n    return undefined;\n}\nexport function arraysIntersect(a, b) {\n    return a.some((av) => b.includes(av));\n}\nexport function sum(arr) {\n    return arr.reduce((a, b) => a + b);\n}\nexport function chainLength(root) {\n    let count = 0;\n    while (root) {\n        count += 1;\n        root = root.next;\n    }\n    return count;\n}\nexport function chainIncludes(chain, entry) {\n    while (chain && chain !== entry) {\n        chain = chain.next;\n    }\n    return (chain === entry);\n}\nexport function eachChain(item, fn) {\n    let index = 0;\n    while (item) {\n        const next = item.next;\n        fn(item, index++);\n        item = next;\n    }\n    return index; // really count\n}\nexport function addToChain(obj, name, entry) {\n    entry.next = obj[name] || null;\n    obj[name] = entry;\n    return true;\n}\nexport function removeFromChain(obj, name, entry) {\n    const root = obj[name];\n    if (root === entry) {\n        obj[name] = entry.next || null;\n        entry.next = null;\n        return true;\n    }\n    else if (!root) {\n        return false;\n    }\n    else {\n        let prev = root;\n        let current = prev.next;\n        while (current && current !== entry) {\n            prev = current;\n            current = prev.next;\n        }\n        if (current === entry) {\n            prev.next = current.next || null;\n            entry.next = null;\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=utils.js.map","const RANDOM_CONFIG = {\n    make: () => { return Math.random.bind(Math); }\n};\nexport function configure(opts) {\n    if (opts.make) {\n        if (typeof opts.make !== 'function')\n            throw new Error('Random make parameter must be a function.');\n        if (typeof opts.make(12345) !== 'function')\n            throw new Error('Random make function must accept a numeric seed and return a random function.');\n        RANDOM_CONFIG.make = opts.make;\n        random.seed();\n        cosmetic.seed();\n    }\n}\nfunction lotteryDrawArray(rand, frequencies) {\n    let i, maxFreq, randIndex;\n    maxFreq = 0;\n    for (i = 0; i < frequencies.length; i++) {\n        maxFreq += frequencies[i];\n    }\n    if (maxFreq <= 0) {\n        console.warn('Lottery Draw - no frequencies', frequencies, frequencies.length);\n        return 0;\n    }\n    randIndex = rand.range(0, maxFreq - 1);\n    for (i = 0; i < frequencies.length; i++) {\n        if (frequencies[i] > randIndex) {\n            return i;\n        }\n        else {\n            randIndex -= frequencies[i];\n        }\n    }\n    console.warn('Lottery Draw failed.', frequencies, frequencies.length);\n    return 0;\n}\nfunction lotteryDrawObject(rand, weights) {\n    const entries = Object.entries(weights);\n    const frequencies = entries.map(([_, weight]) => weight);\n    const index = lotteryDrawArray(rand, frequencies);\n    return entries[index][0];\n}\nexport class Random {\n    constructor() {\n        this._fn = RANDOM_CONFIG.make();\n    }\n    seed(val) {\n        this._fn = RANDOM_CONFIG.make(val);\n    }\n    value() { return this._fn(); }\n    float() { return this.value(); }\n    number(max = 0) {\n        max = max || Number.MAX_SAFE_INTEGER;\n        return Math.floor(this._fn() * max);\n    }\n    int(max = 0) { return this.number(max); }\n    range(lo, hi) {\n        if (hi <= lo)\n            return hi;\n        const diff = (hi - lo) + 1;\n        return lo + (this.number(diff));\n    }\n    dice(count, sides, addend = 0) {\n        let total = 0;\n        let mult = 1;\n        if (count < 0) {\n            count = -count;\n            mult = -1;\n        }\n        addend = addend || 0;\n        for (let i = 0; i < count; ++i) {\n            total += this.range(1, sides);\n        }\n        total *= mult;\n        return total + addend;\n    }\n    weighted(weights) {\n        if (Array.isArray(weights)) {\n            return lotteryDrawArray(this, weights);\n        }\n        return lotteryDrawObject(this, weights);\n    }\n    item(list) {\n        if (!Array.isArray(list)) {\n            list = Object.values(list);\n        }\n        return list[this.range(0, list.length - 1)];\n    }\n    key(obj) {\n        return this.item(Object.keys(obj));\n    }\n    shuffle(list, fromIndex = 0, toIndex = 0) {\n        if (arguments.length == 2) {\n            toIndex = fromIndex;\n            fromIndex = 0;\n        }\n        let i, r, buf;\n        toIndex = toIndex || list.length;\n        fromIndex = fromIndex || 0;\n        for (i = fromIndex; i < toIndex; i++) {\n            r = this.range(fromIndex, toIndex - 1);\n            if (i != r) {\n                buf = list[r];\n                list[r] = list[i];\n                list[i] = buf;\n            }\n        }\n        return list;\n    }\n    sequence(n) {\n        const list = [];\n        for (let i = 0; i < n; i++) {\n            list[i] = i;\n        }\n        return this.shuffle(list);\n    }\n    chance(percent, outOf = 100) {\n        if (percent <= 0)\n            return false;\n        if (percent >= outOf)\n            return true;\n        return (this.range(0, outOf - 1) < percent);\n    }\n    // Get a random int between lo and hi, inclusive, with probability distribution\n    // affected by clumps.\n    clumped(lo, hi, clumps) {\n        if (hi <= lo) {\n            return lo;\n        }\n        if (clumps <= 1) {\n            return this.range(lo, hi);\n        }\n        let i, total = 0, numSides = Math.floor((hi - lo) / clumps);\n        for (i = 0; i < (hi - lo) % clumps; i++) {\n            total += this.range(0, numSides + 1);\n        }\n        for (; i < clumps; i++) {\n            total += this.range(0, numSides);\n        }\n        return (total + lo);\n    }\n}\nexport const random = new Random();\nexport const cosmetic = new Random();\n//# sourceMappingURL=random.js.map","import { random } from './random';\nexport class Range {\n    constructor(lower, upper = 0, clumps = 1, rng) {\n        this._rng = rng || random;\n        if (Array.isArray(lower)) {\n            clumps = lower[2];\n            upper = lower[1];\n            lower = lower[0];\n        }\n        else if (lower instanceof Range) {\n            clumps = lower.clumps;\n            upper = lower.hi;\n            lower = lower.lo;\n        }\n        if (upper < lower) {\n            [upper, lower] = [lower, upper];\n        }\n        this.lo = lower || 0;\n        this.hi = upper || this.lo;\n        this.clumps = clumps || 1;\n    }\n    value() {\n        return this._rng.clumped(this.lo, this.hi, this.clumps);\n    }\n    toString() {\n        if (this.lo >= this.hi) {\n            return '' + this.lo;\n        }\n        return `${this.lo}-${this.hi}`;\n    }\n}\nexport function make(config, rng) {\n    if (!config)\n        return new Range(0, 0, 0, rng);\n    if (config instanceof Range)\n        return config; // you can supply a custom range object\n    // if (config.value) return config;  // calc or damage\n    if (typeof config == 'function')\n        throw new Error('Custom range functions not supported - extend Range');\n    if (config === undefined || config === null)\n        return new Range(0, 0, 0, rng);\n    if (typeof config == 'number')\n        return new Range(config, config, 1, rng);\n    // @ts-ignore\n    if (config === true || config === false)\n        throw new Error('Invalid random config: ' + config);\n    if (Array.isArray(config)) {\n        return new Range(config[0], config[1], config[2], rng);\n    }\n    if (typeof config !== 'string') {\n        throw new Error('Calculations must be strings.  Received: ' + JSON.stringify(config));\n    }\n    if (config.length == 0)\n        return new Range(0, 0, 0, rng);\n    const RE = /^(?:([+-]?\\d*)[Dd](\\d+)([+-]?\\d*)|([+-]?\\d+)-(\\d+):?(\\d+)?|([+-]?\\d+)~(\\d+)|([+-]?\\d+\\.?\\d*))/g;\n    let results;\n    while ((results = RE.exec(config)) !== null) {\n        if (results[2]) {\n            let count = Number.parseInt(results[1]) || 1;\n            const sides = Number.parseInt(results[2]);\n            const addend = Number.parseInt(results[3]) || 0;\n            const lower = addend + count;\n            const upper = addend + (count * sides);\n            return new Range(lower, upper, count, rng);\n        }\n        else if (results[4] && results[5]) {\n            const min = Number.parseInt(results[4]);\n            const max = Number.parseInt(results[5]);\n            const clumps = Number.parseInt(results[6]);\n            return new Range(min, max, clumps, rng);\n        }\n        else if (results[7] && results[8]) {\n            const base = Number.parseInt(results[7]);\n            const std = Number.parseInt(results[8]);\n            return new Range(base - 2 * std, base + 2 * std, 3, rng);\n        }\n        else if (results[9]) {\n            const v = Number.parseFloat(results[9]);\n            return new Range(v, v, 1, rng);\n        }\n    }\n    throw new Error('Not a valid range - ' + config);\n}\n//# sourceMappingURL=range.js.map","import * as utils_1 from './utils';\nexport { utils_1 as utils };\nimport * as range_1 from './range';\nexport { range_1 as range };\nexport { cosmetic, random } from './random';\nimport * as Random from './random';\nimport * as Range from './range';\nexport function configure(config) {\n    if (config.random) {\n        Random.configure(config.random);\n    }\n}\nexport var types = {\n    Random: Random.Random,\n    Range: Range.Range,\n};\n//# sourceMappingURL=gw.js.map"],"names":["DIRS","clamp","v","min","max","x","src","y","distanceBetween","x1","y1","x2","y2","Math","abs","dirBetween","toX","toY","diffX","diffY","absX","absY","sign","setDefaults","obj","def","custom","dest","Object","keys","forEach","key","origKey","defValue","parts","split","length","shift","undefined","ERROR","current","Array","isArray","slice","message","Error","a","b","pct","dx","dy","floor","dir","x0","y0","findIndex","result","push","fn","diff","steps","c","last","step","currentXValue","maxXValue","sin","PI","omit","map","t","trim","includes","updated","copy","clear","nullify","clone","assignField","field","val","search","concat","fields","data","f","args","console","warn","member","_default","arg","some","av","arr","reduce","root","count","next","chain","entry","item","index","name","prev","RANDOM_CONFIG","make","random","bind","lotteryDrawArray","rand","frequencies","i","maxFreq","randIndex","range","Random","[object Object]","this","_fn","value","Number","MAX_SAFE_INTEGER","number","lo","hi","sides","addend","total","mult","weights","entries","_","weight","lotteryDrawObject","list","values","fromIndex","toIndex","r","buf","arguments","n","shuffle","percent","outOf","clumps","numSides","cosmetic","Range","lower","upper","rng","_rng","clumped","config","JSON","stringify","RE","results","exec","parseInt","base","std","parseFloat","types","Random.Random","Range.Range","opts","seed","Random.configure"],"mappings":"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"}